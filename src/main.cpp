#include <iostream>
#include <cstdint>
#include <vector>
#include <span>
#include <format>

#include <totr/disassembler/ArmDisasm.hpp>
#include <totr/disassembler/ThumbDisasm.hpp>

std::uint32_t read_word16_at(std::span<const std::uint8_t> rom, std::uint32_t pc)  {
    if (pc + 1 >= rom.size()) throw std::out_of_range("PC off ROM");
    return std::uint32_t(rom[pc]) | (std::uint32_t(rom[pc + 1]) << 8);
}

std::uint32_t read_word32_at(std::span<const std::uint8_t> rom, std::uint32_t pc) {
    if (pc + 3 >= rom.size()) throw std::out_of_range("PC off ROM");
    return std::uint32_t(rom[pc]) |
        (std::uint32_t(rom[pc + 1]) << 8) |
        (std::uint32_t(rom[pc + 2]) << 16) |
        (std::uint32_t(rom[pc + 3]) << 24);
}

int main() {
    bool decode_arm = false;

    std::vector <std::uint8_t> opcodes;

    if (decode_arm) {
        opcodes = {
            0x02, 0x00, 0xa1, 0xe0, 0x04, 0x30, 0x83, 0xe2, 0x05, 0x40, 0x04, 0xe0,
            0x3b, 0x00, 0x00, 0xea, 0xff, 0x40, 0xc4, 0xe3, 0x79, 0x00, 0x00, 0xeb,
            0x1e, 0xff, 0x2f, 0xe1, 0x02, 0x01, 0x01, 0xee, 0x00, 0x01, 0x21, 0xee,
            0x02, 0x00, 0x71, 0xe1, 0x00, 0x00, 0x53, 0xe3, 0x07, 0x50, 0x26, 0xe0,
            0x01, 0x32, 0xb1, 0xec, 0xe0, 0x00, 0xb0, 0xe8, 0x08, 0x20, 0x93, 0xe5,
            0x13, 0x11, 0x02, 0xee, 0x91, 0x32, 0x02, 0xee, 0x05, 0x40, 0xa0, 0xe1,
            0x38, 0x61, 0x17, 0xee, 0x00, 0x10, 0x0f, 0xe1, 0x02, 0xf0, 0x21, 0xe1,
            0x91, 0x02, 0x00, 0xe0, 0x07, 0x51, 0x86, 0xe1, 0x00, 0x00, 0x61, 0xe2,
            0x04, 0x20, 0xe3, 0xe0, 0x03, 0x10, 0xc2, 0xe0, 0x02, 0x42, 0xa5, 0xec,
            0x70, 0x00, 0x2d, 0xe9, 0x0e, 0xc1, 0x82, 0xe5, 0x14, 0x30, 0x44, 0xe2,
            0x10, 0x00, 0x00, 0xef, 0x91, 0x00, 0x02, 0xe1, 0x04, 0x00, 0x33, 0xe1,
            0x01, 0x00, 0x15, 0xe3, 0x00, 0x00, 0x4f, 0xe1, 0x1f, 0xf0, 0x68, 0xe3,
            0x91, 0x02, 0x00, 0xE0, 0x91, 0x43, 0x20, 0xE0, 0x91, 0x21, 0x80, 0xE0,
            0x91, 0x21, 0xA0, 0xE0, 0x9B, 0x21, 0x80, 0xE0, 0xF0, 0x00, 0x00, 0xEF,
            0x92, 0x00, 0x0B, 0xE1, 0x92, 0x00, 0x4B, 0xE1, 0x91, 0x00, 0x02, 0xE1,
            0x0c, 0x00, 0x91, 0xe5, 0x04, 0x20, 0x63, 0xe5, 0x10, 0x40, 0x95, 0xe4,
            0x20, 0x60, 0x07, 0xe4, 0x02, 0x00, 0x91, 0xe7, 0xa6, 0x40, 0x65, 0xe7,
            0x49, 0x71, 0x98, 0xe6, 0x00, 0xa0, 0x0b, 0xe6, 0xb2, 0x00, 0x81, 0xe1,
            0xb6, 0x40, 0x95, 0xe0, 0xd9, 0x70, 0x38, 0xe1, 0xf0, 0xa0, 0xdb, 0xe0,
            0xb2, 0x00, 0x91, 0x11, 0xb6, 0x00, 0xe1, 0xe1, 0xb4, 0x21, 0xd3, 0xe0,
            0xd8, 0x40, 0x75, 0xe1, 0xf0, 0x60, 0x57, 0x11, 0x31, 0x1f, 0x80, 0xe8,
            0xff, 0xff, 0x80, 0xe8, 0x03, 0x00, 0x80, 0xe8, 0x07, 0x00, 0x80, 0xe8,
            0x08, 0x90, 0x80, 0xe8, 0x00, 0x80, 0x80, 0xe8
        };
    }
    else {
        opcodes = {
            0xEA, 0x0E, 0x18, 0x19, 0x96, 0x1F, 0x80, 0x20, 0x3E, 0x2A, 0xFF, 0x31,
            0x91, 0x3E, 0x63, 0x40, 0xC1, 0x41, 0x5D, 0x42, 0xB2, 0x42, 0x78, 0x43,
            0xAF, 0x44, 0x64, 0x45, 0xF7, 0x46, 0x8B, 0x46, 0x58, 0x47, 0x07, 0x44,
            0x07, 0x45, 0x07, 0x46, 0x87, 0x47, 0xB7, 0x47, 0xD3, 0x4B, 0x93, 0x51,
            0xC2, 0x5D, 0x1C, 0x52, 0x7A, 0x56, 0xA3, 0x5E, 0x6A, 0x6F, 0x41, 0x73,
            0x0E, 0x87, 0xBC, 0x88, 0x7B, 0x94, 0x8F, 0xA2, 0x35, 0xAE
        };
    }

    std::span<const uint8_t> rom{ opcodes };
    totr::Disassembler::ThumbDisasm d{ false };

    std::cout << "  Addr   : Instr   : Mnemonic" << std::endl;
    std::cout << "--------------------------------" << std::endl;

    std::uint32_t instr = 0;
    totr::Disassembler::InstructionDataThumb value;
    for (int pc = 0; pc < rom.size(); pc += 2) {
        if (decode_arm) instr = read_word32_at(rom, pc);
        else instr = read_word16_at(rom, pc);

        value = d.decode(pc, instr);

        std::cout << std::format("#0x{:04X}", value.pc) << " : " << std::format("#0x{:04X}", value.instruction) << " : " << value.mnemonic << std::endl;
    }

    return 0;
}
